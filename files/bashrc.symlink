#!/usr/bin/env bash
# [ -n "$_BASHRC" ] && return || readonly _BASHRC=1

# shellcheck source=./profile.symlink
source "$HOME/.profile"

# history
export HISTFILE="$HOME/.history"
export HISTSIZE=100
export SAVEHIST=100

# locales
export LANG="en_US.UTF-8"
export LANGUAGE=en_US
export LC_COLLATE="C"
export LC_CTYPE="UTF-8"
export LC_MESSAGES="C"
export LC_MONETARY="C"
export LC_NUMERIC="C"
export LC_TIME="C"
export LC_ALL=

# ulimit -S -c 0      # Dont want coredumps.
set -o notify
set -o noclobber
set -o ignoreeof

# Enable options:
shopt -s cdspell
shopt -s cdable_vars
shopt -s checkhash
shopt -s checkwinsize
shopt -s sourcepath
shopt -s no_empty_cmd_completion
shopt -s cmdhist
shopt -s histappend histreedit histverify
shopt -s extglob       # Necessary for programmable completion.

complete -A hostname   ssh scp rsh rcp telnet rlogin ftp ping
complete -A export     printenv
complete -A variable   export local readonly unset
complete -A enabled    builtin
complete -A alias      alias unalias
complete -A function   function
complete -A helptopic  help     # Currently same as builtins.
complete -A shopt      shopt
complete -A stopped -P '%' bg
complete -A job -P '%'     fg jobs disown
complete -A directory  mkdir rmdir
complete -A directory   -o default cd

RED="$(tput setaf 1)"
GREEN="$(tput setaf 2)"
YELLOW="$(tput setaf 3)"
BLUE="$(tput setaf 4)"
RESET="$(tput sgr0)"


git_branch () {
  local branch=""
  branch=$(git status 2>/dev/null | sed -n 's/On branch //p')
  if [ ${#branch} -gt 15 ]; then
    branch_tmp="${branch:0:8}...${branch: -5}"
    branch=$branch_tmp
  fi
  echo $branch
}

git_status () {
  status=""
  unstaged=$(git status|grep -i 'not staged')
  untracked=$(git status|grep -i untracked)
  if [ -n "${unstaged}" ]; then
    status+="~"
  fi
  if [ -n "${untracked}" ]; then
    status+="Â±"
  fi
  if [ -n "${status}" ]; then
    status=":${status}"
  fi
  echo "$status"
}

prompt_command () {
  local exit_code=$?
  local git_name=$(git_branch)

  local ps1="[${GREEN}\w${RESET}] "
  if [ -n "$git_name" ]; then
    status=$(git_status)
    ps1+="[${BLUE}${git_name}${RED}${status}${RESET}] "
  fi
  if [ $exit_code -ne 0 ]; then
    ps1+="[${RED}Exit ${exit_code}${RESET}] "
  fi

  # if ps1 is long, add a new line
  if [ ${#PWD} -gt 40 ]; then
    ps1+="\n\$ "
  fi
  export PS1=$ps1

  # fix history to be always up-to-date
  history -a; history -c; history -r
}

PROMPT_COMMAND=prompt_command
