#!/usr/bin/env bash
# [ -n "$_BASHRC" ] && return || readonly _BASHRC=1

# shellcheck source=./profile.symlink
source "$HOME/.profile"

# history
# export HISTFILE="$HOME/.history"
export HISTSIZE=100
export SAVEHIST=100

# locales
export LANG="en_US.UTF-8"
export LANGUAGE=en_US
export LC_COLLATE="C"
export LC_CTYPE="UTF-8"
export LC_MESSAGES="C"
export LC_MONETARY="C"
export LC_NUMERIC="C"
export LC_TIME="C"
export LC_ALL=

# ulimit -S -c 0      # Dont want coredumps.
set -o notify
set -o noclobber
set -o ignoreeof

# Enable options:
shopt -s cdspell
shopt -s cdable_vars
shopt -s checkhash
shopt -s checkwinsize
shopt -s sourcepath
shopt -s no_empty_cmd_completion
shopt -s cmdhist
shopt -s histappend
shopt -s extglob       # Necessary for programmable completion.

complete -A hostname   ssh scp rsh rcp telnet rlogin ftp ping
complete -A export     printenv
complete -A variable   export local readonly unset
complete -A enabled    builtin
complete -A alias      alias unalias
complete -A function   function
complete -A helptopic  help     # Currently same as builtins.
complete -A shopt      shopt
complete -A stopped -P '%' bg
complete -A job -P '%'     fg jobs disown
complete -A directory  mkdir rmdir
complete -A directory   -o default cd



# \[ and \] are required to tell bash these are codes without length
RED="\[$(tput setaf 1)\]"
GREEN="\[$(tput setaf 2)\]"
YELLOW="\[$(tput setaf 3)\]"
BLUE="\[$(tput setaf 4)\]"
ROSE="\[$(tput setaf 5)\]"
LIGHTGREEN="\[$(tput setaf 6)\]"
WHITE="\[$(tput setaf 7)\]"
BRANCH_COLOR="$GREEN"
RESET="\[$(tput sgr0)\]"

# print the git branch
git_branch () {
  local branch=""
  branch=$(git status 2>/dev/null | sed -n 's/On branch //p')
  if [ ${#branch} -gt 15 ]; then
    branch_tmp="${branch:0:8}...${branch: -5}"
    branch=$branch_tmp
  fi
  echo "$branch"
}

# print a code that represents the git status
git_status () {
  status=""
  stdout=$(git status)

  ahead=$(echo "$stdout"|grep -i ahead)
  behind=$(echo "$stdout"|grep -i behind)
  tobecom=$(echo "$stdout"|grep 'to be committed')
  unmerged=$(echo "$stdout"|grep -i unmerged)
  unstaged=$(echo "$stdout"|grep -i 'not staged')
  untracked=$(echo "$stdout"|grep -i untracked)

  [ -n "${untracked}" ] && { status+="±"; BRANCH_COLOR="$LIGHTGREEN"; }
  [ -n "${unstaged}" ]  && { status+="~"; BRANCH_COLOR="$YELLOW"; }
  [ -n "${ahead}" ]     && { status+="↑"; BRANCH_COLOR="$ROSE"; }
  [ -n "${behind}" ]    && { status+="↓"; BRANCH_COLOR="$ROSE"; }
  [ -n "${tobecom}" ]   && { status+="↺"; BRANCH_COLOR="$WHITE"; }
  [ -n "${unmerged}" ]  && { status+="☠"; BRANCH_COLOR="$BLUE"; }

  echo "$status"
}

prompt_command () {
  local git_name
  local exit_code=$?
  git_name=$(git_branch)

  # update the title bar for xterms
  echo -en "\033]0;$PWD\a"

  local ps1="[${GREEN}\w${RESET}] "
  if [ -n "$git_name" ]; then
    status=$(git_status)
    ps1+="[${BRANCH_COLOR}${git_name}${status}${RESET}] "
  fi
  if [ $exit_code -ne 0 ]; then
    ps1+="[${RED}Exit ${exit_code}${RESET}] "
  fi

  # if ps1 is long, add a new line
  [ ${#PWD} -gt 40 ] && ps1+="\n\$ "

  export PS1=$ps1

  # fix history to be always up-to-date
  # history -a; history -c; history -r
}

PROMPT_COMMAND=prompt_command
